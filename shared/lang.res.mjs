// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Spice from "@greenlabs/ppx-spice/src/rescript/Spice.res.mjs";
import * as Js_dict from "rescript/lib/es6/Js_dict.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as LangBcJs from "./lang.bc.js";

function const_encode(v) {
  switch (v.TAG) {
    case "String" :
      return [
        "String",
        Spice.stringToJson(v._0)
      ];
    case "Int" :
      return [
        "Int",
        Spice.intToJson(v._0)
      ];
    case "Bool" :
      return [
        "Bool",
        Spice.boolToJson(v._0)
      ];
  }
}

function const_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = Belt_Array.getExn(v, 0);
  if (typeof match === "string") {
    switch (match) {
      case "Bool" :
        if (v.length !== 2) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        }
        let v0 = Spice.boolFromJson(Belt_Array.getExn(v, 1));
        if (v0.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              TAG: "Bool",
              _0: v0._0
            }
          };
        }
        let e = v0._0;
        return {
          TAG: "Error",
          _0: {
            path: "[0]" + e.path,
            message: e.message,
            value: e.value
          }
        };
      case "Int" :
        if (v.length !== 2) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        }
        let v0$1 = Spice.intFromJson(Belt_Array.getExn(v, 1));
        if (v0$1.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              TAG: "Int",
              _0: v0$1._0
            }
          };
        }
        let e$1 = v0$1._0;
        return {
          TAG: "Error",
          _0: {
            path: "[0]" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
      case "String" :
        if (v.length !== 2) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        }
        let v0$2 = Spice.stringFromJson(Belt_Array.getExn(v, 1));
        if (v0$2.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              TAG: "String",
              _0: v0$2._0
            }
          };
        }
        let e$2 = v0$2._0;
        return {
          TAG: "Error",
          _0: {
            path: "[0]" + e$2.path,
            message: e$2.message,
            value: e$2.value
          }
        };
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", Belt_Array.getExn(v, 0));
}

function attr_value_encode(v) {
  if (typeof v !== "object") {
    return ["AttrFunc"];
  } else {
    return [
      "AttrConst",
      const_encode(v._0)
    ];
  }
}

function attr_value_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = Belt_Array.getExn(v, 0);
  if (typeof match === "string") {
    switch (match) {
      case "AttrConst" :
        if (v.length !== 2) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        }
        let v0 = const_decode(Belt_Array.getExn(v, 1));
        if (v0.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              TAG: "AttrConst",
              _0: v0._0
            }
          };
        }
        let e = v0._0;
        return {
          TAG: "Error",
          _0: {
            path: "[0]" + e.path,
            message: e.message,
            value: e.value
          }
        };
      case "AttrFunc" :
        if (v.length !== 1) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        } else {
          return {
            TAG: "Ok",
            _0: "AttrFunc"
          };
        }
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", Belt_Array.getExn(v, 0));
}

function tree_encode(v) {
  if (v.TAG === "Const") {
    return [
      "Const",
      const_encode(v._0)
    ];
  } else {
    return [
      "Elem",
      elem_encode(v._0)
    ];
  }
}

function tree_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = Belt_Array.getExn(v, 0);
  if (typeof match === "string") {
    switch (match) {
      case "Const" :
        if (v.length !== 2) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        }
        let v0 = const_decode(Belt_Array.getExn(v, 1));
        if (v0.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              TAG: "Const",
              _0: v0._0
            }
          };
        }
        let e = v0._0;
        return {
          TAG: "Error",
          _0: {
            path: "[0]" + e.path,
            message: e.message,
            value: e.value
          }
        };
      case "Elem" :
        if (v.length !== 2) {
          return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
        }
        let v0$1 = elem_decode(Belt_Array.getExn(v, 1));
        if (v0$1.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              TAG: "Elem",
              _0: v0$1._0
            }
          };
        }
        let e$1 = v0$1._0;
        return {
          TAG: "Error",
          _0: {
            path: "[0]" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", Belt_Array.getExn(v, 0));
}

function elem_encode(v) {
  let extra = v.attrs;
  return Js_dict.fromArray(Spice.filterOptional([
    [
      "name",
      Spice.stringToJson(v.name)
    ],
    [
      "attrs",
      Spice.listToJson(param => ([
        Spice.stringToJson(param[0]),
        attr_value_encode(param[1])
      ]), extra)
    ],
    [
      "children",
      Spice.listToJson(tree_encode, v.children)
    ]
  ]));
}

function elem_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let name_result = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(v, "name"), Spice.stringFromJson), Spice.error(undefined, "name" + " missing", v));
  let attrs_result = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(v, "attrs"), extra => Spice.listFromJson(json => {
    if (!Array.isArray(json)) {
      return Spice.error(undefined, "Not a tuple", json);
    }
    if (json.length !== 2) {
      return Spice.error(undefined, "Incorrect cardinality", json);
    }
    let v0 = json[0];
    let v1 = json[1];
    let match = Spice.stringFromJson(v0);
    let match$1 = attr_value_decode(v1);
    if (match.TAG === "Ok") {
      if (match$1.TAG === "Ok") {
        return {
          TAG: "Ok",
          _0: [
            match._0,
            match$1._0
          ]
        };
      }
      let e = match$1._0;
      return {
        TAG: "Error",
        _0: {
          path: "[1]" + e.path,
          message: e.message,
          value: e.value
        }
      };
    }
    let e$1 = match._0;
    return {
      TAG: "Error",
      _0: {
        path: "[0]" + e$1.path,
        message: e$1.message,
        value: e$1.value
      }
    };
  }, extra)), Spice.error(undefined, "attrs" + " missing", v));
  let children_result = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(v, "children"), extra => Spice.listFromJson(tree_decode, extra)), Spice.error(undefined, "children" + " missing", v));
  if (name_result.TAG === "Ok") {
    if (attrs_result.TAG === "Ok") {
      if (children_result.TAG === "Ok") {
        return {
          TAG: "Ok",
          _0: {
            name: name_result._0,
            attrs: attrs_result._0,
            children: children_result._0
          }
        };
      }
      let e = children_result._0;
      return Spice.error("children", e.message, e.value);
    }
    let e$1 = attrs_result._0;
    return Spice.error("attrs", e$1.message, e$1.value);
  }
  let e$2 = name_result._0;
  return Spice.error("name", e$2.message, e$2.value);
}

function _parse(prim) {
  return LangBcJs.parse(prim);
}

function parse(prog) {
  return tree_decode(LangBcJs.parse(prog));
}

export {
  const_encode,
  const_decode,
  attr_value_encode,
  attr_value_decode,
  tree_encode,
  tree_decode,
  elem_encode,
  elem_decode,
  _parse,
  parse,
}
/* ./lang.bc.js Not a pure module */
